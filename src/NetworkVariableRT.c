/*******************************************************************************
* This example uses the Network Variable library to communicate between a
* DLL running on a real-time target and an executable running on a host machine.
* The real-time DLL generates and publishes sine wave data based on the 
* amplitude and frequency specified by the host executable. When the host 
* executable exits it signals the real-time DLL to exit as well.
*
* This example uses several network variables. Two network variables communicate 
* the amplitude and frequency information from the host executable to the real-
* time DLL. Another network variable publishes the sine wave data from the real-
* time DLL to the host executable. One more network variable indicates that the 
* host executable is exiting so the real-time DLL can exit as well.
*
* The real-time DLL uses multiple threads. The main thread publishes data while
* Network Variable Library threads run callbacks when network variable values
* are updated. The real-time DLL uses thread safe variables to pass data between
* the network variable callbacks and the main thread.
*
* NOTE: This example requires the LabWindows/CVI Real-Time Module.
*
* This example consists of two projects:
*
* NetworkVariableHost.prj - This project builds an executable with a user 
* interface. This executable communicates with the real-time DLL over TCP via 
* the Network Variable Library.
*
* NetworkVariableRT.prj - This project builds a DLL that will run on a real-time
* target. This DLL interacts with the host executable over TCP via the Network
* Variable Library. Download and run the DLL on a real-time target. See the 
* LabWindows/CVI documentation for detailed instructions.
*
* Run the real-time DLL project first and then run the host executable. When you
* exit the host executable the real-time DLL project will also exit.
*******************************************************************************/

/* Include files */
#include <rtutil.h>
#include "cvirte_connection.h"

#include <analysis.h>
#include <utility.h>
#include <cvinetv.h>
#include <cvirte.h>
#include <ansi_c.h>
#include <rtutil.h>
#include "common.h"

/* Global variables */
static CNVSubscriber			gAmplitudeSubscriber, gFrequencySubscriber,
								gStopSubscriber;
static CNVBufferedWriter		gWavePublisher;
volatile int					gDone;

// Create thread safe variables to pass data from Network Variable Library 
// threads to the main thread.
// The DefineThreadSafeVar macro is defined in <utility.h> and automatically
// generates functions to initialize, uninitialize, set the value, and get the
// value of the thread safe variable.
DefineThreadSafeVar( double, Amplitude );
DefineThreadSafeVar( double, Frequency );

/* Function prototypes */
void CVICALLBACK AmplitudeFrequencyDataCallback( void * handle, CNVData data, void * callbackData );
void CVICALLBACK StopDataCallback( void * handle, CNVData data, void * callbackData );

/* Program entry-point */
void CVIFUNC_C RTmain( void )
{
	double			wave[NUM_POINTS] = {0}, phase = 0.0, value;
	CNVData			data = 0;
	CNVDataType		type;
	size_t			arrayDims = NUM_POINTS;
	unsigned long	scalarDims;
	
	if( InitCVIRTE( 0, 0, 0 ) == 0 )
		return;
  
	// Initialize the thread safe variables using the functions generated by
	// the DefineThreadSafeVar macro.
	InitializeAmplitude();
	InitializeFrequency();
	
	// Set the intial values of the thread safe variables using the functions
	// generated by the DefineThreadSafeVar macro.
	SetAmplitude( 1.0 );
	SetFrequency( 0.01 );
	
	int status;
	int systemStarted = 0;
	
	while( !RTIsShuttingDown() && !systemStarted )
	{
		//printf( "System process not started yet\n\n" );
		status = CNVProcessIsRunning( PROCESS, &systemStarted );
		if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
		SleepUS( 100000 );
	}
	
	printf( "System process started !\n\n" );
  
  SleepUS( 1000000 );

  int serverId = async_connection_open( NULL, "50000", TCP );
  DEBUG_EVENT( "Received server connection ID %d", serverId );
  //int clientId = async_connection_open( "169.254.118.91", "50000", UDP );
	
	
	/*status = CNVNewVariable( PROCESS, AMPLITUDE_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVNewVariable( PROCESS, FREQUENCY_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVNewVariable( PROCESS, WAVE_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVNewVariable( PROCESS, STOP_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );*/
	
	// Create network variable connections.
	status = CNVCreateSubscriber("\\\\localhost\\" PROCESS "\\" AMPLITUDE_VARIABLE, 
		AmplitudeFrequencyDataCallback, 0, 0, 10000, 0, &gAmplitudeSubscriber);
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVCreateSubscriber("\\\\localhost\\" PROCESS "\\" FREQUENCY_VARIABLE, 
		AmplitudeFrequencyDataCallback, 0, 0, 10000, 0, &gFrequencySubscriber);
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVCreateSubscriber("\\\\localhost\\" PROCESS "\\" STOP_VARIABLE, 
		StopDataCallback, 0, 0, 10000, 0, &gStopSubscriber);
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVCreateBufferedWriter("\\\\localhost\\" PROCESS "\\" WAVE_VARIABLE, 
		0, 0, 0, 10, 10000, 0, &gWavePublisher);
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	
	// If the host executable has already written a value to the network variable 
	// then use that as the intial amplitude value.
	CNVGetConnectionAttribute(gAmplitudeSubscriber, CNVMostRecentDataAttribute, &data);
	CNVGetDataType (data, &type, &scalarDims);
	if (type != CNVEmpty)
	{
		CNVGetScalarDataValue(data, CNVDouble, &value);
		SetAmplitude(value);
		CNVDisposeData(data);
		data = 0;
	}
	
	// If the host executable has already written a value to the network variable 
	// then use that as the intial frequency value.
	CNVGetConnectionAttribute(gFrequencySubscriber, CNVMostRecentDataAttribute, &data);
	CNVGetDataType (data, &type, &scalarDims);
	if (type != CNVEmpty)
	{
		CNVGetScalarDataValue(data, CNVDouble, &value);
		SetFrequency(value);
		CNVDisposeData(data);
		data = 0;
	}
		
	// Generate the sine wave. Get the values of the thread safe variables using the 
	// functions generated by the DefineThreadSafeVar macro.
	//
	// This example uses the SineWave function from the Advanced Analysis Library, which
	// is only included in the LabWindows/CVI Full Development System. If you are using 
	// the LabWindows/CVI Base package this example will not compile without modifications.
	SineWave(NUM_POINTS, GetAmplitude(), GetFrequency(), &phase, wave);
	CNVCreateArrayDataValue(&data, CNVDouble, wave, 1, &arrayDims);
	CNVPutDataInBuffer(gWavePublisher, data, 1000);
	while (!RTIsShuttingDown() && !gDone) // Check for program termination conditions
	{
		SineWave(NUM_POINTS, GetAmplitude(), GetFrequency(), &phase, wave);
		CNVSetArrayDataValue(data, CNVDouble, wave, 1, &arrayDims);
		CNVPutDataInBuffer(gWavePublisher, data, 1000);
    
    SleepUS(100000); // Sleep to give the desired loop rate.
	}

	// Cleanup
	gDone = 1;
	if (data)
		CNVDisposeData(data);
	if (gAmplitudeSubscriber)
		CNVDispose(gAmplitudeSubscriber);
	if (gFrequencySubscriber)
		CNVDispose(gFrequencySubscriber);
	if (gStopSubscriber)
		CNVDispose(gStopSubscriber);
	if (gWavePublisher)
		CNVDispose(gWavePublisher);
	CNVFinish();
	// Uninitialize the thread safe variables using the functions generated by
	// the DefineThreadSafeVar macro.
	UninitializeAmplitude();
	UninitializeFrequency();
	
  //async_connection_close( clientId );
  async_connection_close( serverId );
  
	/*status = CNVDeleteVariable( PROCESS, AMPLITUDE_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVDeleteVariable( PROCESS, FREQUENCY_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVDeleteVariable( PROCESS, WAVE_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
	status = CNVDeleteVariable( PROCESS, STOP_VARIABLE );
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );*/
	
	CloseCVIRTE();
}

void CVICALLBACK AmplitudeFrequencyDataCallback(void * handle, CNVData data, 
	void * callbackData)
{
	double value;
	
	if (gDone)
		goto Done;

	if (handle == gAmplitudeSubscriber)
	{
		CNVGetScalarDataValue(data, CNVDouble, &value);
		// Update the thread safe variable using the macro-generated function.
		// See thread safe variable definition using DefineThreadSafeVar macro.
		SetAmplitude(value);
	}
	else if (handle == gFrequencySubscriber)
	{
		CNVGetScalarDataValue(data, CNVDouble, &value);
		// Update the thread safe variable using the macro-generated function.
		// See thread safe variable definition using DefineThreadSafeVar macro.
		SetFrequency(value);
	}
	
Done:
	CNVDisposeData(data);
}

void CVICALLBACK StopDataCallback(void * handle, CNVData data, void * callbackData)
{
	char stop;
	
	if (gDone)
		goto Done;

	CNVGetScalarDataValue(data, CNVBool, &stop);
	if (stop)
		gDone = 1; // Signal the main thread to exit the while loop in RTMain
	
Done:
	CNVDisposeData(data);
}

