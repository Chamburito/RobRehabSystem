/*******************************************************************************
* This example uses the Network Variable library to communicate between a
* DLL running on a real-time target and an executable running on a host machine.
* The real-time DLL generates and publishes sine wave data based on the 
* amplitude and frequency specified by the host executable. When the host 
* executable exits it signals the real-time DLL to exit as well.
*
* This example uses several network variables. Two network variables communicate 
* the amplitude and frequency information from the host executable to the real-
* time DLL. Another network variable publishes the sine wave data from the real-
* time DLL to the host executable. One more network variable indicates that the 
* host executable is exiting so the real-time DLL can exit as well.
*
* The real-time DLL uses multiple threads. The main thread publishes data while
* Network Variable Library threads run callbacks when network variable values
* are updated. The real-time DLL uses thread safe variables to pass data between
* the network variable callbacks and the main thread.
*
* NOTE: This example requires the LabWindows/CVI Real-Time Module.
*
* This example consists of two projects:
*
* NetworkVariableHost.prj - This project builds an executable with a user 
* interface. This executable communicates with the real-time DLL over TCP via 
* the Network Variable Library.
*
* NetworkVariableRT.prj - This project builds a DLL that will run on a real-time
* target. This DLL interacts with the host executable over TCP via the Network
* Variable Library. Download and run the DLL on a real-time target. See the 
* LabWindows/CVI documentation for detailed instructions.
*
* Run the real-time DLL project first and then run the host executable. When you
* exit the host executable the real-time DLL project will also exit.
*******************************************************************************/

/* Include files */
#include <rtutil.h>
#include "robrehab_network.h"

#include <analysis.h>
#include <utility.h>
#include <cvinetv.h>
#include <cvirte.h>
#include <ansi_c.h>
#include <rtutil.h>
#include "common.h"

/* Global variables */
static CNVSubscriber gStopSubscriber;
volatile int gDone;

/* Program entry-point */
void CVIFUNC_C RTmain( void )
{
	CNVData	data = 0;
	
	if( InitCVIRTE( 0, 0, 0 ) == 0 )
		return;
  
	// Initialize the thread safe variables using the functions generated by
	// the DefineThreadSafeVar macro.
	InitializeAmplitude();
	InitializeFrequency();
	
	// Set the intial values of the thread safe variables using the functions
	// generated by the DefineThreadSafeVar macro.
	SetAmplitude( 1.0 );
	SetFrequency( 0.0 );
	
	int status;
	int systemStarted = 0;
	
	while( !RTIsShuttingDown() && !systemStarted )
	{
		//printf( "System process not started yet\n\n" );
		status = CNVProcessIsRunning( PROCESS, &systemStarted );
		if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
		SleepUS( 100000 );
	}
  
  SleepUS( 1000000 );
	
  RobRehabNetwork_Init();
	
	status = CNVCreateSubscriber("\\\\localhost\\" PROCESS "\\" STOP_VARIABLE, 
		StopDataCallback, 0, 0, 10000, 0, &gStopSubscriber);
	if( status != 0 ) printf( "%s\n\n", CNVGetErrorDescription( status ) );
		
	while (!RTIsShuttingDown() && !gDone) // Check for program termination conditions
	{
    RobRehabNetwork_Update();
    
    SleepUS( 1000 ); // Sleep to give the desired loop rate.
	}

  RobRehabNetwork_End();
  
	// Cleanup
	gDone = 1;
	if( data )
		CNVDisposeData(data);
	if (gStopSubscriber)
		CNVDispose(gStopSubscriber);
	CNVFinish();
	
	CloseCVIRTE();
}

void CVICALLBACK StopDataCallback(void * handle, CNVData data, void * callbackData)
{
	char stop;
	
	if (gDone)
		goto Done;

	CNVGetScalarDataValue(data, CNVBool, &stop);
	if (stop)
		gDone = 1; // Signal the main thread to exit the while loop in RTMain
	
Done:
	CNVDisposeData(data);
}

